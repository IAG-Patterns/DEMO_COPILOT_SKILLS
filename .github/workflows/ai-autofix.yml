name: AI Autofix (PR Comments & Vulnerabilities)

on:
  workflow_dispatch:
    inputs:
      pr_url:
        description: 'Pull Request URL (e.g., https://github.com/owner/repo/pull/123)'
        required: true
        type: string
      ai_provider:
        description: 'AI Provider to use for fixes'
        required: true
        default: 'claude'
        type: choice
        options:
          - claude
          - warp
      fix_pr_comments:
        description: 'Fix PR review comments'
        required: true
        default: true
        type: boolean
      fix_vulnerabilities:
        description: 'Fix security vulnerabilities'
        required: true
        default: true
        type: boolean

permissions:
  contents: write
  pull-requests: write
  actions: read
  checks: read
  statuses: read
  id-token: write

jobs:
  # ============================================
  # SHARED: Parse PR and Export Comments
  # ============================================
  prepare:
    runs-on: ubuntu-latest
    outputs:
      owner: ${{ steps.parse_pr.outputs.owner }}
      repo: ${{ steps.parse_pr.outputs.repo }}
      pr_number: ${{ steps.parse_pr.outputs.pr_number }}
      head_ref: ${{ steps.pr_details.outputs.head_ref }}
      head_sha: ${{ steps.pr_details.outputs.head_sha }}
      base_ref: ${{ steps.pr_details.outputs.base_ref }}
      pr_title: ${{ steps.pr_details.outputs.pr_title }}
      task_count: ${{ steps.build_tasks.outputs.task_count }}
      has_security_logs: ${{ steps.fetch_security.outputs.has_security_logs }}
    env:
      GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN || github.token }}
    
    steps:
      - name: Parse PR URL
        id: parse_pr
        run: |
          PR_URL="${{ github.event.inputs.pr_url }}"
          
          if [[ "$PR_URL" =~ github\.com/([^/]+)/([^/]+)/pull/([0-9]+) ]]; then
            OWNER="${BASH_REMATCH[1]}"
            REPO="${BASH_REMATCH[2]}"
            PR_NUMBER="${BASH_REMATCH[3]}"
          elif [[ "$PR_URL" =~ ([^/]+)/([^#]+)\#([0-9]+) ]]; then
            OWNER="${BASH_REMATCH[1]}"
            REPO="${BASH_REMATCH[2]}"
            PR_NUMBER="${BASH_REMATCH[3]}"
          else
            echo "Error: Invalid PR URL format"
            exit 1
          fi
          
          echo "owner=$OWNER" >> $GITHUB_OUTPUT
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "Parsed PR: $OWNER/$REPO#$PR_NUMBER"

      - name: Get PR Details
        id: pr_details
        run: |
          OWNER="${{ steps.parse_pr.outputs.owner }}"
          REPO="${{ steps.parse_pr.outputs.repo }}"
          PR_NUMBER="${{ steps.parse_pr.outputs.pr_number }}"
          
          PR_DATA=$(gh api "/repos/$OWNER/$REPO/pulls/$PR_NUMBER")
          
          echo "head_ref=$(echo "$PR_DATA" | jq -r '.head.ref')" >> $GITHUB_OUTPUT
          echo "head_sha=$(echo "$PR_DATA" | jq -r '.head.sha')" >> $GITHUB_OUTPUT
          echo "base_ref=$(echo "$PR_DATA" | jq -r '.base.ref')" >> $GITHUB_OUTPUT
          echo "pr_title=$(echo "$PR_DATA" | jq -r '.title')" >> $GITHUB_OUTPUT

      - name: Checkout PR Branch
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.parse_pr.outputs.owner }}/${{ steps.parse_pr.outputs.repo }}
          ref: ${{ steps.pr_details.outputs.head_ref }}
          path: ./repo
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN || github.token }}

      - name: Fetch PR Comments
        if: github.event.inputs.fix_pr_comments == 'true'
        run: |
          OWNER="${{ steps.parse_pr.outputs.owner }}"
          REPO="${{ steps.parse_pr.outputs.repo }}"
          PR_NUMBER="${{ steps.parse_pr.outputs.pr_number }}"
          
          # Fetch conversation comments
          gh api "/repos/$OWNER/$REPO/issues/$PR_NUMBER/comments" --paginate \
            --jq '[.[] | {id, type: "conversation", author: .user.login, author_type: .user.type, body: .body, created_at, html_url}]' \
            > conversation_comments.json
          
          # Fetch review comments (inline)
          gh api "/repos/$OWNER/$REPO/pulls/$PR_NUMBER/comments" --paginate \
            --jq '[.[] | {id, type: "review", author: .user.login, author_type: .user.type, body: .body, path, line, original_line, diff_hunk, in_reply_to_id, html_url, created_at}]' \
            > review_comments.json
          
          # Fetch reviews
          gh api "/repos/$OWNER/$REPO/pulls/$PR_NUMBER/reviews" --paginate \
            --jq '[.[] | {id, type: "review_summary", author: .user.login, state, body, submitted_at, html_url}]' \
            > reviews.json

      - name: Build Refactor Tasks
        id: build_tasks
        if: github.event.inputs.fix_pr_comments == 'true'
        env:
          PR_NUMBER: ${{ steps.parse_pr.outputs.pr_number }}
          OWNER: ${{ steps.parse_pr.outputs.owner }}
          REPO: ${{ steps.parse_pr.outputs.repo }}
          PR_TITLE: ${{ steps.pr_details.outputs.pr_title }}
        run: |
          # Build refactor_tasks.json
          jq -n --argjson review "$(cat review_comments.json)" \
            '[
              $review[]
              | select(.line != null and .author_type != "Bot")
              | . as $root
              | {
                  file: .path,
                  line: .line,
                  author: .author,
                  created_at: .created_at,
                  comment: .body,
                  conversation: ([{author: .author, body: .body}] + ($review | map(select(.in_reply_to_id == $root.id)) | map({author, body}))),
                  html_url: .html_url,
                  suggestion_type: "refactor",
                  status: "active"
                }
            ]' > ./repo/refactor_tasks.json
          
          # Build PR_conversations.json
          jq -n \
            --argjson conversation "$(cat conversation_comments.json)" \
            --argjson review "$(cat review_comments.json)" \
            --argjson reviews "$(cat reviews.json)" \
            --arg pr_number "$PR_NUMBER" --arg owner "$OWNER" --arg repo "$REPO" --arg pr_title "$PR_TITLE" \
            '{
              metadata: {pull_request: {number: ($pr_number|tonumber), owner: $owner, repo: $repo, title: $pr_title}},
              comments: {conversation: $conversation, reviews: $review, review_summaries: $reviews}
            }' > ./repo/PR_conversations.json
          
          TASK_COUNT=$(jq 'length' ./repo/refactor_tasks.json)
          echo "task_count=$TASK_COUNT" >> $GITHUB_OUTPUT
          echo "Created $TASK_COUNT refactor tasks"

      - name: Fetch Security Scan Logs via GH CLI
        id: fetch_security
        if: github.event.inputs.fix_vulnerabilities == 'true'
        continue-on-error: true
        run: |
          OWNER="${{ steps.parse_pr.outputs.owner }}"
          REPO="${{ steps.parse_pr.outputs.repo }}"
          PR_NUMBER="${{ steps.parse_pr.outputs.pr_number }}"
          HEAD_SHA="${{ steps.pr_details.outputs.head_sha }}"
          
          echo "ðŸ” Searching for security scan workflow runs for PR #$PR_NUMBER..."
          
          # Initialize output file
          mkdir -p ./repo
          echo "# Security Scan Results for PR #$PR_NUMBER" > ./repo/snyk_scan.log
          echo "# Generated at: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> ./repo/snyk_scan.log
          echo "" >> ./repo/snyk_scan.log
          
          # Method 1: Find PR CI workflow run by commit SHA
          echo "ðŸ“‹ Looking for workflow runs on commit $HEAD_SHA..."
          
          WORKFLOW_RUNS=$(gh api "/repos/$OWNER/$REPO/actions/runs?head_sha=$HEAD_SHA&per_page=10" \
            --jq '.workflow_runs[] | select(.name | test("PR CI|Security|Snyk|Build"; "i")) | {id, name, conclusion, jobs_url}' 2>/dev/null || echo "")
          
          if [ -n "$WORKFLOW_RUNS" ]; then
            echo "Found workflow runs:"
            echo "$WORKFLOW_RUNS" | jq -s '.'
            
            # Get the first matching run
            RUN_ID=$(echo "$WORKFLOW_RUNS" | jq -r '.id' | head -1)
            
            if [ -n "$RUN_ID" ] && [ "$RUN_ID" != "null" ]; then
              echo "" >> ./repo/snyk_scan.log
              echo "## Workflow Run ID: $RUN_ID" >> ./repo/snyk_scan.log
              echo "" >> ./repo/snyk_scan.log
              
              # Get all jobs from this run
              echo "ðŸ“¥ Fetching jobs from workflow run $RUN_ID..."
              JOBS=$(gh api "/repos/$OWNER/$REPO/actions/runs/$RUN_ID/jobs" --jq '.jobs[] | {id, name, conclusion, steps}' 2>/dev/null || echo "")
              
              if [ -n "$JOBS" ]; then
                # Get job IDs for security-related jobs
                JOB_IDS=$(echo "$JOBS" | jq -r 'select(.name | test("scan|snyk|security|build"; "i")) | .id' 2>/dev/null || echo "")
                
                for JOB_ID in $JOB_IDS; do
                  if [ -n "$JOB_ID" ] && [ "$JOB_ID" != "null" ]; then
                    JOB_NAME=$(echo "$JOBS" | jq -r "select(.id == $JOB_ID) | .name" 2>/dev/null || echo "Job $JOB_ID")
                    echo "ðŸ“„ Downloading logs for job: $JOB_NAME (ID: $JOB_ID)..."
                    
                    echo "### Job: $JOB_NAME" >> ./repo/snyk_scan.log
                    echo '```' >> ./repo/snyk_scan.log
                    
                    # Download job logs
                    gh api -H "Accept: application/vnd.github+json" \
                      "/repos/$OWNER/$REPO/actions/jobs/$JOB_ID/logs" >> ./repo/snyk_scan.log 2>/dev/null || \
                      echo "Failed to download logs for job $JOB_ID" >> ./repo/snyk_scan.log
                    
                    echo '```' >> ./repo/snyk_scan.log
                    echo "" >> ./repo/snyk_scan.log
                  fi
                done
              fi
            fi
          fi
          
          # Method 2: Try to download artifacts from the PR CI run
          echo "ðŸ“¦ Looking for security scan artifacts..."
          
          ARTIFACTS=$(gh api "/repos/$OWNER/$REPO/actions/runs?head_sha=$HEAD_SHA&per_page=5" \
            --jq '.workflow_runs[0].id' 2>/dev/null || echo "")
          
          if [ -n "$ARTIFACTS" ] && [ "$ARTIFACTS" != "null" ]; then
            # List artifacts from this run
            ARTIFACT_LIST=$(gh api "/repos/$OWNER/$REPO/actions/runs/$ARTIFACTS/artifacts" \
              --jq '.artifacts[] | select(.name | test("security|scan|snyk"; "i")) | {id, name}' 2>/dev/null || echo "")
            
            if [ -n "$ARTIFACT_LIST" ]; then
              echo "" >> ./repo/snyk_scan.log
              echo "## Artifacts Found" >> ./repo/snyk_scan.log
              
              ARTIFACT_IDS=$(echo "$ARTIFACT_LIST" | jq -r '.id' 2>/dev/null || echo "")
              
              for ARTIFACT_ID in $ARTIFACT_IDS; do
                if [ -n "$ARTIFACT_ID" ] && [ "$ARTIFACT_ID" != "null" ]; then
                  ARTIFACT_NAME=$(echo "$ARTIFACT_LIST" | jq -r "select(.id == $ARTIFACT_ID) | .name" 2>/dev/null || echo "artifact")
                  echo "ðŸ“¥ Downloading artifact: $ARTIFACT_NAME..."
                  
                  # Download and extract artifact
                  gh api "/repos/$OWNER/$REPO/actions/artifacts/$ARTIFACT_ID/zip" > artifact_$ARTIFACT_ID.zip 2>/dev/null || true
                  
                  if [ -f "artifact_$ARTIFACT_ID.zip" ]; then
                    unzip -o "artifact_$ARTIFACT_ID.zip" -d "./artifact_$ARTIFACT_ID" 2>/dev/null || true
                    
                    # Append any log files found
                    find "./artifact_$ARTIFACT_ID" -name "*.log" -o -name "*.sarif" -o -name "*.json" | while read -r file; do
                      echo "### File: $(basename "$file")" >> ./repo/snyk_scan.log
                      echo '```' >> ./repo/snyk_scan.log
                      cat "$file" >> ./repo/snyk_scan.log 2>/dev/null || true
                      echo '```' >> ./repo/snyk_scan.log
                      echo "" >> ./repo/snyk_scan.log
                    done
                    
                    rm -rf "artifact_$ARTIFACT_ID.zip" "./artifact_$ARTIFACT_ID"
                  fi
                fi
              done
            fi
          fi
          
          # Method 3: Check PR checks for Snyk status
          echo "ðŸ”Ž Checking PR status checks..."
          
          PR_CHECKS=$(gh pr checks "$PR_NUMBER" --repo "$OWNER/$REPO" 2>/dev/null || echo "")
          
          if [ -n "$PR_CHECKS" ]; then
            echo "" >> ./repo/snyk_scan.log
            echo "## PR Check Status" >> ./repo/snyk_scan.log
            echo '```' >> ./repo/snyk_scan.log
            echo "$PR_CHECKS" >> ./repo/snyk_scan.log
            echo '```' >> ./repo/snyk_scan.log
          fi
          
          # Method 4: Get Snyk-specific comments on the PR (Snyk bot comments)
          echo "ðŸ’¬ Fetching Snyk bot comments..."
          
          SNYK_COMMENTS=$(gh api "/repos/$OWNER/$REPO/issues/$PR_NUMBER/comments" \
            --jq '.[] | select(.user.login | test("snyk"; "i")) | {author: .user.login, body: .body, created_at}' 2>/dev/null || echo "")
          
          if [ -n "$SNYK_COMMENTS" ]; then
            echo "" >> ./repo/snyk_scan.log
            echo "## Snyk Bot Comments" >> ./repo/snyk_scan.log
            echo '```json' >> ./repo/snyk_scan.log
            echo "$SNYK_COMMENTS" | jq -s '.' >> ./repo/snyk_scan.log
            echo '```' >> ./repo/snyk_scan.log
          fi
          
          # Verify we got some content
          if [ -s ./repo/snyk_scan.log ] && [ $(wc -l < ./repo/snyk_scan.log) -gt 5 ]; then
            echo "âœ… Security scan logs collected successfully"
            echo "has_security_logs=true" >> $GITHUB_OUTPUT
            
            # Show summary
            echo "ðŸ“Š Log file size: $(wc -c < ./repo/snyk_scan.log) bytes, $(wc -l < ./repo/snyk_scan.log) lines"
            head -50 ./repo/snyk_scan.log
          else
            echo "âš ï¸ No significant security logs found"
            echo "has_security_logs=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: pr-data-${{ steps.parse_pr.outputs.pr_number }}
          path: |
            ./repo/PR_conversations.json
            ./repo/refactor_tasks.json
            ./repo/snyk_scan.log
          retention-days: 30

  # ============================================
  # CLAUDE: Run Claude Code Agent
  # ============================================
  claude-fix:
    needs: prepare
    if: github.event.inputs.ai_provider == 'claude'
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN || github.token }}
      SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
    
    steps:
      - name: Checkout PR Branch
        uses: actions/checkout@v4
        with:
          repository: ${{ needs.prepare.outputs.owner }}/${{ needs.prepare.outputs.repo }}
          ref: ${{ needs.prepare.outputs.head_ref }}
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN || github.token }}

      - name: Download PR Data
        uses: actions/download-artifact@v4
        with:
          name: pr-data-${{ needs.prepare.outputs.pr_number }}
          path: .

      - name: Configure Git and Create Branch
        id: setup_branch
        env:
          PR_NUMBER: ${{ needs.prepare.outputs.pr_number }}
        run: |
          git config user.name "claude-code-agent"
          git config user.email "claude-agent@anthropic.com"
          
          # Create unique branch name with timestamp
          TIMESTAMP=$(date +%s)
          BRANCH_NAME="claude-refactor/pr-${PR_NUMBER}-${TIMESTAMP}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          git checkout -b "$BRANCH_NAME"
          echo "Created branch: $BRANCH_NAME"

      - name: Run Claude Code Agent
        id: claude_agent
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are an autonomous AI security remediation and refactoring agent.

            ## Context
            - Working on PR #${{ needs.prepare.outputs.pr_number }} in ${{ needs.prepare.outputs.owner }}/${{ needs.prepare.outputs.repo }}
            - PR Title: "${{ needs.prepare.outputs.pr_title }}"
            - Security logs available: ${{ needs.prepare.outputs.has_security_logs }}
            - SNYK_TOKEN is available in environment for running scans
            
            ## Available Files
            - `refactor_tasks.json`: Actionable inline review comments with file paths and line numbers
            - `PR_conversations.json`: Full PR conversation including review summaries
            - `snyk_scan.log`: **CRITICAL** - Contains Snyk security scanner results including:
              - Container/Dockerfile vulnerabilities
              - Dependency vulnerabilities (npm, pip, etc.)
              - **License compliance issues** (LGPL, GPL, Artistic, etc.)
              - Code vulnerabilities
              - PR check statuses

            ## Goals (Priority Order)
            
            ### 1. Fix Security Vulnerabilities
            Read snyk_scan.log carefully and address ALL issues:
            
            **Dockerfile Security:**
            - Update base image to latest secure version (e.g., node:22-alpine)
            - **IMPORTANT**: If Snyk reports npm vulnerabilities (in tar, cross-spawn, glob, etc.), 
              add `RUN npm install -g npm@latest` AFTER the base image to upgrade npm itself
            - Add USER directive to run as non-root
            - Remove hardcoded secrets/credentials
            - Fix file permissions (no 777)
            - Add HEALTHCHECK instruction
            - Remove unnecessary EXPOSE ports
            
            **Dependency Vulnerabilities:**
            - Upgrade vulnerable packages to patched versions
            - **Check Snyk output for npm@X.X.X vulnerabilities** - these require upgrading npm in Dockerfile
            - Check npm/yarn for latest safe versions: `npm view <package> versions --json`
            - Use `npm audit fix` first, then manual upgrades for breaking changes
            - For transitive dependencies, try `npm update <package>` or add resolutions/overrides
            
            **Code Vulnerabilities:**
            - Fix injection risks, XSS, path traversal, etc.
            - Address any SAST findings
            
            ### 2. Handle License Compliance Issues
            Snyk reports license issues like LGPL-3.0, GPL, Artistic-2.0. Handle them:
            
            **For LGPL-3.0 (e.g., sharp-libvips):**
            - These are transitive deps from Next.js image optimization
            - Option A: Accept (LGPL is permissive for web apps - just requires attribution)
            - Option B: Disable image optimization in next.config.js: `images: { unoptimized: true }`
            - Option C: Use alternative package if available
            
            **For Artistic-2.0 (e.g., npm):**
            - This is the npm CLI itself, not a runtime dependency - can be ignored
            
            **Create .snyk policy file to document accepted licenses:**
            ```yaml
            version: v1.25.0
            ignore:
              'snyk:lic:npm:img:sharp-libvips-*:LGPL-3.0':
                - '*':
                    reason: 'LGPL-3.0 accepted - transitive dependency from Next.js image optimization'
                    expires: 2027-01-01T00:00:00.000Z
            ```
            
            ### 3. Iterative Fix Loop with Verification
            After making fixes, verify and iterate:
            
            ```bash
            # Step 1: Install dependencies
            npm install --legacy-peer-deps
            
            # Step 2: Run local Snyk scan
            npx snyk test --severity-threshold=medium 2>&1 | tee snyk_local_results.txt
            
            # Step 3: Check results
            if grep -q "found [0-9]* issues" snyk_local_results.txt; then
              echo "Issues remain - analyzing for additional fixes..."
              # Read snyk_local_results.txt and apply more fixes
            fi
            
            # Step 4: Repeat up to 3 times or until clean
            ```
            
            ### 4. Apply PR Review Comments
            Process refactor_tasks.json:
            - TypeScript type improvements
            - Code style fixes  
            - Accessibility improvements
            - Remove console.log statements
            - Fix == to === operators
            
            ### 5. Final Verification
            - Run `npm run lint` 
            - Run `npm run build`
            - Run final `npx snyk test` to confirm fixes

            ## Constraints
            - Non-interactive environment - no prompts
            - DO NOT create git commits - workflow handles this
            - DO NOT use subshells like `bash -c '...'`
            - Maximum 3 fix iterations to avoid infinite loops
            - Skip tasks where code no longer exists

            ## Output
            Print JSON summary when finished:
            ```json
            {
              "security_fixes": {
                "dockerfile": ["list of fixes"],
                "dependencies": ["list of upgrades"],
                "code": ["list of fixes"]
              },
              "license_fixes": {
                "accepted": ["licenses accepted with reason"],
                "mitigated": ["licenses mitigated by removing/replacing package"],
                "policy_file_created": boolean
              },
              "review_fixes": {
                "applied": number,
                "skipped": number
              },
              "verification": {
                "iterations": number,
                "final_snyk_clean": boolean,
                "lint_passed": boolean,
                "build_passed": boolean
              }
            }
            ```
          
          claude_args: |
            --dangerously-skip-permissions
            --allowedTools "Bash" "Edit" "Read" "Write" "LS" "Glob" "Grep"
            --max-turns 75

      - name: Save Claude Summary
        id: claude_summary
        run: |
          # Extract the JSON summary from Claude's output (look for the JSON block)
          AGENT_OUTPUT='${{ steps.claude_agent.outputs.stdout }}'
          
          # Try to extract JSON summary from output
          echo "$AGENT_OUTPUT" | grep -Pzo '(?s)\{[^{}]*"security_fixes"[^{}]*\{.*?\}.*?\}' > claude_summary.json 2>/dev/null || true
          
          # Build a human-readable summary
          SUMMARY=""
          
          # Check git diff for what files changed
          CHANGED_FILES=$(git diff --name-only HEAD~0 2>/dev/null || git diff --name-only)
          if [ -n "$CHANGED_FILES" ]; then
            SUMMARY="### ðŸ“ Files Modified\n"
            for f in $CHANGED_FILES; do
              SUMMARY="$SUMMARY- \`$f\`\n"
            done
            SUMMARY="$SUMMARY\n"
          fi
          
          # Count changes
          ADDITIONS=$(git diff --stat 2>/dev/null | tail -1 | grep -oP '\d+(?= insertion)' || echo "0")
          DELETIONS=$(git diff --stat 2>/dev/null | tail -1 | grep -oP '\d+(?= deletion)' || echo "0")
          
          if [ "$ADDITIONS" != "0" ] || [ "$DELETIONS" != "0" ]; then
            SUMMARY="$SUMMARY### ðŸ“Š Change Statistics\n- **+$ADDITIONS** insertions, **-$DELETIONS** deletions\n\n"
          fi
          
          # Save summary for PR body
          echo -e "$SUMMARY" > pr_summary.txt
          echo "summary<<EOF" >> $GITHUB_OUTPUT
          echo -e "$SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Commit and Create PR
        env:
          PR_NUMBER: ${{ needs.prepare.outputs.pr_number }}
          OWNER: ${{ needs.prepare.outputs.owner }}
          REPO: ${{ needs.prepare.outputs.repo }}
          HEAD_REF: ${{ needs.prepare.outputs.head_ref }}
          BRANCH_NAME: ${{ steps.setup_branch.outputs.branch_name }}
          GH_TOKEN: ${{ secrets.CLAUDE_PR_TOKEN }}
        run: |
          # Clean up generated files (keep summary)
          rm -f refactor_tasks.json PR_conversations.json snyk_scan.log
          
          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit"
            exit 0
          fi
          
          # Stage and commit
          git add -A
          git commit -m "Claude AI: Apply review feedback for PR #$PR_NUMBER"
          
          # Push the new branch
          echo "Pushing branch: $BRANCH_NAME"
          git push https://x-access-token:${GH_TOKEN}@github.com/${OWNER}/${REPO}.git HEAD:refs/heads/$BRANCH_NAME
          
          # Build PR body with summary
          PR_BODY=$(cat <<'PREOF'
          ## ðŸ¤– Automated Fixes by Claude Code Agent

          This PR contains automated fixes for PR #${{ needs.prepare.outputs.pr_number }}.

          ${{ steps.claude_summary.outputs.summary }}
          ### ðŸ”§ What was fixed

          **Security Vulnerabilities:**
          - Dockerfile security improvements (base image, permissions, secrets)
          - Dependency updates for vulnerable packages

          **Code Quality:**
          - Applied PR review comment suggestions
          - TypeScript type improvements
          - Code style and accessibility fixes

          ---

          **Merge this PR** to apply the changes to branch \`${{ needs.prepare.outputs.head_ref }}\`.

          _Generated automatically by [Claude Code Agent](https://github.com/anthropics/claude-code-action)_
          PREOF
          )
          
          # Create PR targeting the original PR's branch
          echo "Creating PR: $BRANCH_NAME â†’ $HEAD_REF"
          NEW_PR_URL=$(gh pr create --repo "$OWNER/$REPO" \
            --base "$HEAD_REF" \
            --head "$BRANCH_NAME" \
            --title "ðŸ¤– Claude AI fixes for PR #$PR_NUMBER" \
            --body "$PR_BODY")
          
          # Comment on the original PR with link to the new PR
          gh pr comment "$PR_NUMBER" --repo "$OWNER/$REPO" --body "## ðŸ¤– Claude Code Agent

          I've analyzed the review comments and security scan results, then created a PR with fixes:

          **âž¡ï¸ $NEW_PR_URL**

          ${{ steps.claude_summary.outputs.summary }}

          Please review and merge that PR to apply the changes to this branch."

  # ============================================
  # WARP: Run Warp Agent
  # ============================================
  warp-fix:
    needs: prepare
    if: github.event.inputs.ai_provider == 'warp'
    runs-on: ubuntu-latest
    env:
      WARP_API_KEY: ${{ secrets.WARP_API_KEY }}
      GH_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN || github.token }}
      SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
    
    steps:
      - name: Checkout PR Branch
        uses: actions/checkout@v4
        with:
          repository: ${{ needs.prepare.outputs.owner }}/${{ needs.prepare.outputs.repo }}
          ref: ${{ needs.prepare.outputs.head_ref }}
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN || github.token }}

      - name: Download PR Data
        uses: actions/download-artifact@v4
        with:
          name: pr-data-${{ needs.prepare.outputs.pr_number }}
          path: .

      - name: Configure Git and Create Branch
        id: setup_branch
        env:
          PR_NUMBER: ${{ needs.prepare.outputs.pr_number }}
        run: |
          git config user.name "warp-agent"
          git config user.email "agent@warp.dev"
          
          # Create unique branch name with timestamp
          TIMESTAMP=$(date +%s)
          BRANCH_NAME="warp-refactor/pr-${PR_NUMBER}-${TIMESTAMP}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          git checkout -b "$BRANCH_NAME"
          echo "Created branch: $BRANCH_NAME"

      - name: Run Warp Agent
        id: run-warp-agent
        uses: warpdotdev/warp-agent-action@v1
        with:
          warp_api_key: ${{ secrets.WARP_API_KEY }}
          cwd: .
          prompt: |
            You are an autonomous AI security remediation and refactoring agent running inside a GitHub Actions workflow.

            ## Context
            - Working on PR #${{ needs.prepare.outputs.pr_number }} in ${{ needs.prepare.outputs.owner }}/${{ needs.prepare.outputs.repo }}
            - PR Title: "${{ needs.prepare.outputs.pr_title }}"
            - Security logs available: ${{ needs.prepare.outputs.has_security_logs }}
            - SNYK_TOKEN is available in environment for running scans
            
            ## Available Files
            - `refactor_tasks.json`: Actionable inline review comments with file paths and line numbers
            - `PR_conversations.json`: Full PR conversation including review summaries  
            - `snyk_scan.log`: **CRITICAL** - Contains comprehensive Snyk security scanner results:
              - Container/Dockerfile vulnerabilities
              - Dependency vulnerability reports
              - **License compliance issues** (LGPL, GPL, Artistic, etc.)
              - Code vulnerabilities
              - PR check statuses

            ## Goals (Priority Order)

            ### 1. Fix Security Vulnerabilities (PRIORITY)
            Read snyk_scan.log thoroughly and address ALL security issues:
            
            **Dockerfile Security:**
            - Update base image to latest secure version (e.g., node:22-alpine)
            - **IMPORTANT**: If Snyk reports npm vulnerabilities (in tar, cross-spawn, glob, diff, etc.), 
              add `RUN npm install -g npm@latest` AFTER the FROM instruction to upgrade npm itself
            - Add `USER node` to avoid running as root
            - Remove hardcoded secrets (ENV with passwords, API keys)
            - Fix insecure permissions (no chmod 777)
            - Add HEALTHCHECK instruction
            - Remove unnecessary EXPOSE ports
            - Never pipe curl/wget to bash
            
            **Dependency Vulnerabilities:**
            - Upgrade vulnerable packages to patched versions
            - **Check Snyk output for npm@X.X.X vulnerabilities** - these require upgrading npm in Dockerfile
            - Check for latest safe versions: `npm view <package> versions --json`
            - Use `npm audit fix` first, then manual upgrades for breaking changes
            - For transitive deps, try `npm update <package>` or add overrides in package.json
            
            **Code Vulnerabilities:**
            - Fix injection risks, XSS, path traversal
            - Address any SAST findings

            ### 2. Handle License Compliance Issues
            Snyk reports license issues like LGPL-3.0, GPL, Artistic-2.0. Handle them:
            
            **For LGPL-3.0 (e.g., @img/sharp-libvips-*):**
            - These come from Next.js image optimization
            - Option A: Accept (LGPL is permissive for web apps - requires attribution only)
            - Option B: Disable image optimization in next.config.js: `images: { unoptimized: true }`
            
            **For Artistic-2.0 (e.g., npm):**
            - This is the npm CLI, not a runtime dep - can be ignored
            
            **Create .snyk policy file to document accepted licenses:**
            ```yaml
            version: v1.25.0
            ignore:
              'snyk:lic:npm:img:sharp-libvips-*:LGPL-3.0':
                - '*':
                    reason: 'LGPL-3.0 accepted for Next.js image optimization'
                    expires: 2027-01-01T00:00:00.000Z
            ```
            
            ### 3. Iterative Fix Loop with Verification
            After making fixes, verify and iterate up to 3 times:
            
            ```bash
            # Step 1: Install dependencies
            npm install --legacy-peer-deps
            
            # Step 2: Run local Snyk scan
            npx snyk test --severity-threshold=medium 2>&1 | tee snyk_local_results.txt
            
            # Step 3: Check if issues remain
            if grep -q "found [0-9]* issues" snyk_local_results.txt; then
              echo "Issues remain - applying more fixes..."
              # Parse snyk_local_results.txt and fix remaining issues
            fi
            
            # Step 4: Repeat until clean or max 3 iterations
            ```

            ### 4. Apply PR Review Comments
            Process refactor_tasks.json:
            - Apply TypeScript improvements
            - Fix code style issues
            - Add accessibility attributes
            - Remove console.log statements
            - Fix == to === operators

            ### 5. Final Verification
            - Run `npm run lint`
            - Run `npm run build`
            - Run final `npx snyk test` to confirm fixes

            ## Constraints
            - Fully non-interactive environment - no prompts
            - DO NOT create git commits - workflow handles this
            - DO NOT use subshells like `bash -c '...'`
            - Maximum 3 fix iterations to avoid infinite loops
            - Skip tasks where code no longer exists

            ## Required Output
            Print JSON summary when finished:
            ```json
            {
              "security_fixes": {
                "dockerfile": ["list of applied fixes"],
                "dependencies": ["list of upgraded packages"],
                "code": ["list of code fixes"]
              },
              "license_fixes": {
                "accepted": ["licenses accepted with reason"],
                "mitigated": ["licenses mitigated by removing/replacing package"],
                "policy_file_created": boolean
              },
              "review_fixes": {
                "applied": number,
                "skipped": number,
                "skipped_reasons": ["reasons"]
              },
              "verification": {
                "iterations": number,
                "final_snyk_clean": boolean,
                "lint_passed": boolean,
                "build_passed": boolean
              }
            }
            ```

      - name: Save Warp Summary
        id: warp_summary
        run: |
          # Save raw agent output
          cat > warp_ai_refactor_summary.json <<'EOF'
          ${{ steps.run-warp-agent.outputs.agent_output }}
          EOF
          
          # Build a human-readable summary
          SUMMARY=""
          
          # Check git diff for what files changed
          CHANGED_FILES=$(git diff --name-only HEAD~0 2>/dev/null || git diff --name-only)
          if [ -n "$CHANGED_FILES" ]; then
            SUMMARY="### ðŸ“ Files Modified\n"
            for f in $CHANGED_FILES; do
              SUMMARY="$SUMMARY- \`$f\`\n"
            done
            SUMMARY="$SUMMARY\n"
          fi
          
          # Count changes
          ADDITIONS=$(git diff --stat 2>/dev/null | tail -1 | grep -oP '\d+(?= insertion)' || echo "0")
          DELETIONS=$(git diff --stat 2>/dev/null | tail -1 | grep -oP '\d+(?= deletion)' || echo "0")
          
          if [ "$ADDITIONS" != "0" ] || [ "$DELETIONS" != "0" ]; then
            SUMMARY="$SUMMARY### ðŸ“Š Change Statistics\n- **+$ADDITIONS** insertions, **-$DELETIONS** deletions\n\n"
          fi
          
          # Try to parse Warp's JSON output for more details
          if [ -f warp_ai_refactor_summary.json ]; then
            # Extract security fixes count if available
            SEC_FIXES=$(jq -r '.security_fixes | to_entries | map("\(.key): \(.value | length) fixes") | join(", ")' warp_ai_refactor_summary.json 2>/dev/null || echo "")
            if [ -n "$SEC_FIXES" ] && [ "$SEC_FIXES" != "" ]; then
              SUMMARY="$SUMMARY### ðŸ”’ Security Fixes\n$SEC_FIXES\n\n"
            fi
            
            # Extract review fixes count if available
            REVIEW_APPLIED=$(jq -r '.review_fixes.applied // 0' warp_ai_refactor_summary.json 2>/dev/null || echo "0")
            REVIEW_SKIPPED=$(jq -r '.review_fixes.skipped // 0' warp_ai_refactor_summary.json 2>/dev/null || echo "0")
            if [ "$REVIEW_APPLIED" != "0" ] || [ "$REVIEW_SKIPPED" != "0" ]; then
              SUMMARY="$SUMMARY### ðŸ“ Review Comments\n- Applied: $REVIEW_APPLIED\n- Skipped: $REVIEW_SKIPPED\n\n"
            fi
          fi
          
          # Save summary for PR body
          echo -e "$SUMMARY" > pr_summary.txt
          echo "summary<<EOF" >> $GITHUB_OUTPUT
          echo -e "$SUMMARY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Commit and Create PR
        env:
          PR_NUMBER: ${{ needs.prepare.outputs.pr_number }}
          OWNER: ${{ needs.prepare.outputs.owner }}
          REPO: ${{ needs.prepare.outputs.repo }}
          HEAD_REF: ${{ needs.prepare.outputs.head_ref }}
          BRANCH_NAME: ${{ steps.setup_branch.outputs.branch_name }}
          GH_TOKEN: ${{ secrets.CLAUDE_PR_TOKEN }}
        run: |
          rm -f refactor_tasks.json PR_conversations.json snyk_scan.log
          
          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit"
            exit 0
          fi
          
          git add -A
          git commit -m "Warp AI: Apply review feedback for PR #$PR_NUMBER"
          
          # Push the new branch
          echo "Pushing branch: $BRANCH_NAME"
          git push https://x-access-token:${GH_TOKEN}@github.com/${OWNER}/${REPO}.git HEAD:refs/heads/$BRANCH_NAME
          
          # Build PR body with summary
          PR_BODY=$(cat <<'PREOF'
          ## ðŸ¤– Automated Fixes by Warp AI Agent

          This PR contains automated fixes for PR #${{ needs.prepare.outputs.pr_number }}.

          ${{ steps.warp_summary.outputs.summary }}
          ### ðŸ”§ What was fixed

          **Security Vulnerabilities:**
          - Dockerfile security improvements (base image, permissions, secrets)
          - Dependency updates for vulnerable packages

          **Code Quality:**
          - Applied PR review comment suggestions
          - TypeScript type improvements
          - Code style and accessibility fixes

          ---

          **Merge this PR** to apply the changes to branch \`${{ needs.prepare.outputs.head_ref }}\`.

          _Generated automatically by [Warp AI Agent](https://github.com/warpdotdev/warp-agent-action)_
          PREOF
          )
          
          # Create PR targeting the original PR's branch
          echo "Creating PR: $BRANCH_NAME â†’ $HEAD_REF"
          NEW_PR_URL=$(gh pr create --repo "$OWNER/$REPO" \
            --base "$HEAD_REF" \
            --head "$BRANCH_NAME" \
            --title "ðŸ¤– Warp AI fixes for PR #$PR_NUMBER" \
            --body "$PR_BODY")
          
          # Comment on the original PR with link to the new PR
          gh pr comment "$PR_NUMBER" --repo "$OWNER/$REPO" --body "## ðŸ¤– Warp AI Agent

          I've analyzed the review comments and security scan results, then created a PR with fixes:

          **âž¡ï¸ $NEW_PR_URL**

          ${{ steps.warp_summary.outputs.summary }}

          Please review and merge that PR to apply the changes to this branch."

